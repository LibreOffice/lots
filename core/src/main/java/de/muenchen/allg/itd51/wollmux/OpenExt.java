/*-
 * #%L
 * WollMux
 * %%
 * Copyright (C) 2005 - 2023 Landeshauptstadt München and LibreOffice contributors
 * %%
 * Licensed under the EUPL, Version 1.1 or – as soon they will be
 * approved by the European Commission - subsequent versions of the
 * EUPL (the "Licence");
 *
 * You may not use this work except in compliance with the Licence.
 * You may obtain a copy of the Licence at:
 *
 * http://ec.europa.eu/idabc/eupl5
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the Licence is distributed on an "AS IS" basis,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the Licence for the specific language governing permissions and
 * limitations under the Licence.
 * #L%
 */
package de.muenchen.allg.itd51.wollmux;

import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.MalformedURLException;
import java.net.URL;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.sun.star.beans.PropertyValue;
import com.sun.star.frame.XStorable;

import org.libreoffice.ext.unohelper.common.UNO;
import de.muenchen.allg.itd51.wollmux.config.ConfigThingy;
import de.muenchen.allg.itd51.wollmux.config.ConfigurationErrorException;
import de.muenchen.allg.itd51.wollmux.config.NodeNotFoundException;
import de.muenchen.allg.itd51.wollmux.util.L;

/**
 * Class that facilitates calling external applications.
 *
 */
public class OpenExt
{
  private static final Logger LOGGER = LoggerFactory.getLogger(OpenExt.class);
  /**
   * Prefix for directory names to download URLs for ACTION "openExt".
   */
  private static final String WOLLMUX_DOWNLOAD_DIR_PREFIX =
    "wollmuxbar-temp-download-";

  /**
   * The ext parameter passed to the constructor.
   */
  private String ext;

  /**
   * true if DOWNLOAD "true" has been specified for the corresponding application.
   * Ensures that the file is saved locally before calling the external application
   * and that a file path is passed to the external application instead of a URL.
   */
  private boolean download = false;

  /**
   * true if PIPE "true" has been specified with the corresponding application.
   * Ensures that stdout and stderr are kept open and emptied by a thread.
   * Some programs need this.
   */
  private boolean pipe = false;

  /**
   * The list of programs tried at
   * {@link #launch(en.muenchen.allg.itd51.wollmux.OpenExt.ExceptionHandler)} in list order.
   * The first program found is taken.
   */
  private List<String> programs = new ArrayList<>();

  /**
   * If available, the FILTER specification. Possible FILTERs can be found
   * here:base-link/share/registry/modules/org/openoffice/TypeDetection/Filter.
   * Additional PDF filter options are here:
   * http://specs.openoffice.org/appwide/pdf_export/PDFExportDialog.odt
   */
  private String filter = null;

  /**
   * A variant to set the source is {@link #setSource(URL)}.
   * This sets this variable.
   */
  private URL url = null;

  /**
   * A variant to set the source is {@link #setSource(XStorable)}.
   * This sets this variable.
   */
  private XStorable doc = null;

  /**
   * Generated by {@link #prepareTempFile(String)} and
   * written by {@link #storeIfNecessary()}.
   */
  private File destFile = null;

  /** true gdw {@link #storeIfNecessary()} has already been called. */
  private boolean haveStored = false;

  public static OpenExt getInstance(String ext, String url) throws MalformedURLException
  {
    final String USER_HOME = "${user.home}";
    int uhidx = url.indexOf(USER_HOME);
    if (uhidx >= 0)
    {
      String userHomeUrl = new File(System.getProperty("user.home")).toURI().toURL().toString();
      url = Paths.get(userHomeUrl, new File(url).getName()).toString();

      /**
       * When incorporating a URL into an existing URL, there may be duplicates of the
       * protocol identifier file:. In this case, we remove the first of them.
       */
      final Pattern DUPLICATE_FILE_PROTOCOL_PATTERN =
        Pattern.compile("file:/*(file:.*)");
      Matcher m = DUPLICATE_FILE_PROTOCOL_PATTERN.matcher(url);
      if (m.matches()) url = m.group(1);
    }

    URL srcUrl = WollMuxFiles.makeURL(url);
    final OpenExt openExt = new OpenExt(ext, WollMuxFiles.getWollmuxConf());
    openExt.setSource(srcUrl);
    return openExt;
  }

  /**
   * Creates a new OpenExt object for the ext extension, taking information about the external
   * application from wollmuxConf.query("ExternalApplications").
   *
   * ATTENTION! Each OpenExt object can be used only once.
   *
   * @throws ConfigurationErrorException
   *           if no external application is defined (correctly) for ext.
   */
  public OpenExt(String ext, ConfigThingy wollmuxConf)
      throws ConfigurationErrorException
  {
    this.ext = ext;

    ConfigThingy conf = wollmuxConf.query("ExternalApplications");
    for (ConfigThingy parentConf : conf)
    {
      for (ConfigThingy appConf : parentConf)
      {
        ConfigThingy extConf;
        boolean found = false;
        extConf = appConf.query("EXT");
        if (extConf.count() == 0)
        {
          LOGGER.error("Ein Eintrag im Abschnitt \"ExternalApplications\" enthält "
              + "keine gültige EXT-Angabe.");
          continue;
        }

        for (ConfigThingy oneExtConf : extConf)
        {
          for (ConfigThingy singleExt : oneExtConf)
          {
            if (ext.equals(singleExt.toString()))
            {
              found = true;
              break;
            }
          }
        }

        if (!found) continue;

        List<String> commands = new ArrayList<>();
        try
        {
          ConfigThingy programConf = appConf.get("PROGRAM");
          programConf.getFirstChild(); // Test if there is at least one child
          // otherwise exception
          for (ConfigThingy p : programConf)
          {
            String prog = p.toString();
            commands.add(prog);
          }
        }
        catch (NodeNotFoundException e)
        {
          LOGGER.error("One entry within the section \"ExternalApplications\""
              + " contains an invalid PROGRAM-Specification.");
          continue;
        }

        programs = commands;
        download = appConf.getString("DOWNLOAD", "").equalsIgnoreCase("true");
        pipe = appConf.getString("PIPE", "").equalsIgnoreCase("true");
        filter = appConf.getString("FILTER", null);
      }
    }
  }

  /**
   * Returns the list of programs in the order in which
   * {@link #launch(en.muenchen.allg.itd51.wollmux.OpenExt.ExceptionHandler)}
   * will try to execute them.
   * The supplied list is a reference to the internal data.
   * So it is possible to modify it before calling its launch.
   *
   * TESTED
   */
  public List<String> getPrograms()
  {
    return programs;
  }

  /**
   * Specifies `url` as the file with which the external application shall be started.
   * Whether the URL itself is passed as a parameter to the program or whether the
   * contents of the url are downloaded and saved to a file whose path is passed as
   * a parameter is determined by the `DOWNLOAD` specification in the external
   * application definition in lots.conf.
   *
   * @see #setSource(XStorable)
   *
   * TESTED
   */
  public void setSource(URL url)
  {
    this.url = url;
    this.doc = null;
  }

  /**
   * Defines doc as the file to start the external application with.
   * The file is always exported to a temporary file before the external
   * application is started.
   * The format in which the file is saved is determined by the `FILTER`
   * specification in the definition of the external application.
   * Whether the file is passed to the external application as path or as
   * file: URL to the external application is determined by the `DOWNLOAD`
   * specification. The file extension for the temporary file is the ext
   * passed to the constructor.
   * If multiple setSource() functions are called, the last one wins.
   *
   * @throws ConfigurationErrorException
   *
   *           if the `FILTER` specification is missing in the external
   *           application definition.
   *
   * @see #setSource(URL)
   *
   * TESTED
   */
  public void setSource(XStorable doc) throws ConfigurationErrorException
  {
    if (filter == null)
      throw new ConfigurationErrorException(L.m(
        "FILTER specification is missing for application \"{0}\"", ext));
    this.doc = doc;
    this.url = null;
  }

  /**
   * Saves the file to disk if download==true or the source is an XStorable.
   * In the latter case, it does an export that does not change the source
   * URL of the document.
   *
   * @throws IOException
   *           if a problem occurred while saving. *
   * @throws IllegalStateException
   *           if this method was called without first setting a source with
   *           setSource().
   *
   * TESTED
   */
  public void storeIfNecessary() throws IOException, IllegalStateException
  {
    if (haveStored) return;
    haveStored = true;

    testState();

    if (doc != null)
    {
      File tempFile = prepareTempFile(null);

      PropertyValue[] storeProps = new PropertyValue[] { new PropertyValue() };
      storeProps[0].Name = "FilterName";
      storeProps[0].Value = filter;
      try
      {
        String parsedURL =
          UNO.getParsedUNOUrl(tempFile.toURI().toURL().toString()).Complete;
        doc.storeToURL(parsedURL, storeProps);
      }
      catch (Exception x)
      {
        throw new IOException(L.m("Error when storing the file: {0}",
          x.getMessage()));
      }
    }
    else if (download)
    {
      String fileName = url.getPath();
      int idx1 = fileName.lastIndexOf('/');
      int idx2 = fileName.lastIndexOf('\\');
      if (idx2 > idx1) idx1 = idx2;
      if (idx1 >= 0) fileName = fileName.substring(idx1 + 1);

      File tempFile = prepareTempFile(fileName);

      if (!tempFile.createNewFile())
        throw new IOException(L.m("Could not create a temporay file \"{0}\"", tempFile.getPath()));
      try (InputStream istream = url.openStream(); FileOutputStream out = new FileOutputStream(tempFile);)
      {
        byte[] buffy = new byte[4096];
        int len;
        while (0 <= (len = istream.read(buffy)))
          out.write(buffy, 0, len);
      }
    }
  }

  private void testState()
  {
    if (doc == null && url == null)
      throw new IllegalStateException(L.m("setSource() was not called"));
  }

  /**
   * Generates a filename from fileName (can be empty string or null) and creates a
   * temporary directory. The combination of both generates {@link #destFile}.
   *
   * TESTED
   */
  private File prepareTempFile(String fileName) throws IOException
  {
    if (fileName == null) fileName = "";
    File tmpDir = new File(System.getProperty("java.io.tmpdir"));
    if (!tmpDir.isDirectory() || !tmpDir.canWrite())
      throw new IOException(
        L.m(
          "Temporary directory\n\"{0}\"\ndoes not exist or it cannot be written!",
          tmpDir.getPath()));

    File downloadDir = null;
    for (int i = 0; i < 1000; ++i)
    {
      downloadDir = new File(tmpDir, WOLLMUX_DOWNLOAD_DIR_PREFIX + i);
      if (downloadDir.mkdir())
        break;
      else
        downloadDir = null;
    }

    if (downloadDir == null)
      throw new IOException(
        L.m("Could not create a temporary directory for the file download!"));

    if (fileName.length() == 0) fileName = "temp";
    if (!fileName.endsWith("." + ext)) fileName += "." + ext;

    destFile = new File(downloadDir, fileName);
    return destFile;
  }

  public static interface ExceptionHandler
  {
    public void handle(Exception x);
  }

  /**
   * Starts the external application after downloading or exporting the source file
   * if necessary (i.e. if not already done {@link #storeIfNecessary()} is called).
   * ATTENTION! The call is always made in a separate thread.
   * This method returns immediately.
   *
   * Note: It makes a difference if you call {@link #storeIfNecessary()}
   * explicitly before calling this method or not.
   * If {@link #storeIfNecessary()} is not called explicitly,
   * {@link #storeIfNecessary()} is also done in the new thread.
   * One can then no longer distinguish memory problems from program call problems.
   *
   * ATTENTION! In case /loadComponentFromURL/ is included in the programs to
   * try ({@link #getPrograms()}), this method assumes that there is a working
   * LibreOffice connection via {@link UNO}.
   *
   * @param handler
   *          will be called in case of an exception in the thread that is
   *          started by launcher. Exception is the IllegalStateException
   *          in case setSource was not called. This falls out of the method normally.
   *
   * @throws IllegalStateException
   *           if this method was called without setting a source with setSource() before.
   *
   * TESTED
   */
  public void launch(final ExceptionHandler handler) throws IllegalStateException
  {
    testState();

    Thread t = new Thread()
    {
      @Override
      public void run()
      {
        try
        {
          storeIfNecessary();
        }
        catch (Exception x)
        {
          handler.handle(x);
          return;
        }

        String appArgument;
        if (download)
          appArgument = destFile.getAbsolutePath();
        else
        {
          if (url != null)
            appArgument = url.toString();
          else
            try
            {
              appArgument = destFile.toURI().toURL().toString();
            }
            catch (MalformedURLException x)
            {
              appArgument = "file:" + destFile.getAbsolutePath();
            }
        }

        StringBuilder errors = new StringBuilder();
        Iterator<String> iter = programs.iterator();
        while (iter.hasNext())
        {
          String command = iter.next();

          if (command.startsWith("/loadComponentFromURL/") && command.endsWith("/"))
          {
            if (loadComponentFromURL(command, appArgument, errors)) return;
          }
          else
          {
            if (runProgram(command, appArgument, pipe, errors)) return;
          }
        }

        handler.handle(new Exception(
          L.m(
            "None of the programs configured for the extension \"{0}\" could be started!\n{1}",
            ext, errors.toString())));
      }

    };

    t.setDaemon(false);
    t.start();
  }

  /**
   * Attempts to load appArgument using
   * {@link UNO#loadComponentFromURL(String, boolean, short, boolean)}
   * with parameters extracted from command. A LibreOffice connection
   * using {@link UNO} must already exist. Command has the following form
   *
   * <pre>
   *  /loadComponentFromURL/AsTemplate=true/MacroExecutionMode=3/Hidden=false/
   * </pre>
   *
   * where the order of the parameters is arbitrary and not all have to be specified.
   * The above example shows the default values. The following command is equivalent
   *
   * <pre>
   * /loadComponentFromURL/
   * </pre>
   *
   * @param appArgument
   *          the URL of the file to be loaded
   *
   * @param errors
   *          Errors during file loading are appended here.
   *
   * @return true when the file can be loaded.
   */
  private static boolean loadComponentFromURL(String command, String appArgument,
      StringBuilder errors)
  {
    boolean asTemplate = true;
    short macroExecutionMode = 3;
    boolean hidden = false;

    try
    {
      String[] param = command.split("/");
      if (param[0].length() > 0 || !param[1].equals("loadComponentFromURL"))
        throw new IllegalArgumentException();

      for (int i = 2; i < param.length; ++i)
      {
        String arg[] = param[i].split("=");
        if (arg.length != 2)
          throw new IllegalArgumentException(
            L.m("/loadComponentFromURL/ parameter must be of the form \"Param=Value\""));

        if (arg[0].equals("AsTemplate"))
          asTemplate = arg[1].equalsIgnoreCase("true");
        else if (arg[0].equals("Hidden"))
          hidden = arg[1].equalsIgnoreCase("true");
        else if (arg[0].equals("MacroExecutionMode"))
          macroExecutionMode = Short.valueOf(arg[1]);
      }

      return (null != UNO.loadComponentFromURL(
        UNO.getParsedUNOUrl(appArgument).Complete, asTemplate, macroExecutionMode,
        hidden));
    }
    catch (Exception x)
    {
      errors.append(x.toString());
      errors.append('\n');
      return false;
    }
  }

  /**
   * Attempts to start a process to execute command with command line argument appArgument.
   *
   * @param pipe
   *          if true this method empties stdout and stderr of the started process in an infinite loop.
   *          If false they are simply closed. stdin is always closed.
   *
   * @param errors
   *          Errors while running the process are hung here.
   *
   * @return true if the process could be started.
   */
  private static boolean runProgram(String command, String appArgument,
      boolean pipe, StringBuilder errors)
  {
    ProcessBuilder proc = new ProcessBuilder(new String[] {
      command, appArgument });
    proc.redirectErrorStream(true);
    try
    {
      Process process = proc.start();
      // Prevent process from blocking by inputting
      process.getOutputStream().close();

      /*
       * If the started process does input or output, it will block if there is nothing
       * hanging on the other side that writes or reads. Of course, we would prefer to
       * redirect to /dev/null, but Java can't do that (especially not portably).
       * For Stdin, the solution is simple. You close the stream. Every program
       * has to cope with that. For Stdout/Stderr (merged above via redirectErrorStream)
       * you can do that too (and the code below does), but that's a bit nasty because
       * programs, at least on Unix, are not usually designed to not have Stdout+Stderr.
       * If a program has problems with this, a simple shell script can be used as a
       * wrapper that does the redirection to /dev/null.
       *
       * An alternative solution is the code triggered by pipe==true, which simply
       * reads Stdout+Stderr. The unpleasant thing about this solution is that the Java
       * thread continues to run as long as the external program is running.
       */
      if (pipe == false)
      {
        process.getInputStream().close(); // nasty
        process.getErrorStream().close(); // nasty
      }
      else
      {
        InputStream istream = process.getInputStream();
        byte[] buffy = new byte[256];
        int count;
        while ((0 <= (count = istream.read(buffy))))
        {
          if (LOGGER.isInfoEnabled())
          {
            LOGGER.info(new String(buffy, 0, count));
          }
        }
      }
    }
    catch (Exception x)
    {
      errors.append(x.toString());
      errors.append('\n');
      return false;
    }
    return true;
  }

}
